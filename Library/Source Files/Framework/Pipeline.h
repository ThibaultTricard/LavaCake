#pragma once

#include "ShaderModule.h"
#include "VertexBuffer.h"
#include "DescriptorSet.h"

namespace LavaCake {
	namespace Framework {

    struct constant {
      PushConstant*           constant;
      VkShaderStageFlags      stage;
    };

    /**
     Class Pipeline :
     \brief A generic class to help manage VkPipelines, inherited by the classes ComputePipeline and GraphicPipeline
     */
		class Pipeline {
		public :
			/**
       \brief Add a uniform Buffer to the pipeline and scpecify it's binding and shader stage
       \param uniform a pointer to the uniform buffer
       \param stage the shader stage where the uniform buffer is going to be used
       \param binding the binding point of the uniform shader, 0 by default
      */
      [[deprecated("Deprecated: Create your own descriptor set and bind it to the pipeline instead with setDescirptorSet")]]
			virtual void addUniformBuffer(const UniformBuffer& uniform, VkShaderStageFlags stage, int binding = 0) {
        if(!m_descriptorSet){
          m_descriptorSet = std::make_shared< DescriptorSet >();
          m_isDescriptorPipelineGenerated = true;
        }
        if(m_isDescriptorPipelineGenerated){
          m_descriptorSet->addUniformBuffer(uniform,stage,binding);
        }else{
          ErrorCheck::setError("Descritpor is not generated by the pipeline, modifying it this way could affect other pipeline");
        }
			};

			/**
			 \brief Add a texture Buffer to the pipeline and scpecify it's binding and shader stage
       \param texture a pointer to the texture buffer
       \param stage the shader stage where the texture buffer is going to be used
       \param binding the binding point of the texture buffer, 0 by default
			*/
      [[deprecated("Deprecated: Create your own descriptor set and bind it to the pipeline instead with setDescirptorSet")]]
			virtual void addTextureBuffer(const Image& texture, VkShaderStageFlags stage, int binding = 0) {
        if(!m_descriptorSet){
          m_descriptorSet = std::make_shared< DescriptorSet >();
          m_isDescriptorPipelineGenerated = true;
        }
        if(m_isDescriptorPipelineGenerated){
          m_descriptorSet->addTextureBuffer(texture,stage,binding);
        }else{
          ErrorCheck::setError("Descritpor is not generated by the pipeline, modifying it this way could affect other pipeline");
        }
      };

			/**
			 \brief Add a frame Buffer to the pipeline and scpecify it's binding and shader stage
       \param frame a pointer to the frame buffer
       \param stage the shader stage where the frame buffer is going to be used
       \param binding the binding point of the frame buffer, 0 by default
			*/
      [[deprecated("Deprecated: Create your own descriptor set and bind it to the pipeline instead with setDescirptorSet")]]
			virtual void addFrameBuffer(const FrameBuffer& frame, VkShaderStageFlags stage, int binding = 0, uint32_t view = 0) {
        if(!m_descriptorSet){
          m_descriptorSet = std::make_shared< DescriptorSet >();
          m_isDescriptorPipelineGenerated = true;
        }
        if(m_isDescriptorPipelineGenerated){
          m_descriptorSet->addFrameBuffer(frame,stage,binding,view);
        }else{
          ErrorCheck::setError("Descritpor is not generated by the pipeline, modifying it this way could affect other pipeline");
        }
			}; 

			/**
			 \brief Add a storage Image to the pipeline and scpecify it's binding and shader stage
       \param storage a pointer to the frame buffer
       \param stage the shader stage where the storage image is going to be used
       \param binding the binding point of the storage image, 0 by default
			*/
      [[deprecated("Deprecated: Create your own descriptor set and bind it to the pipeline instead with setDescirptorSet")]]
			virtual void addStorageImage(const Image& storage, VkShaderStageFlags stage, int binding = 0) {
        if(!m_descriptorSet){
          m_descriptorSet = std::make_shared< DescriptorSet >();
          m_isDescriptorPipelineGenerated = true;
        }
        if(m_isDescriptorPipelineGenerated){
          m_descriptorSet->addStorageImage(storage,stage,binding);
        }else{
          ErrorCheck::setError("Descritpor is not generated by the pipeline, modifying it this way could affect other pipeline");
        }
			}; 


			/**
			 \brief Add an attachment to the pipeline and scpecify it's binding and shader stage
       \param attachement a pointer to the attachement
       \param stage the shader stage where the storage image is going to be used
       \param binding the binding point of the storage image, 0 by default
			*/
      [[deprecated("Deprecated: Create your own descriptor set and bind it to the pipeline instead with setDescirptorSet")]]
			virtual void addAttachment(std::shared_ptr<Image> attachement, VkShaderStageFlags stage, int binding = 0) {
        if(!m_descriptorSet){
          m_descriptorSet = std::make_shared< DescriptorSet >();
          m_isDescriptorPipelineGenerated = true;
        }
        if(m_isDescriptorPipelineGenerated){
          m_descriptorSet->addAttachment(attachement,stage,binding);
        }else{
          ErrorCheck::setError("Descritpor is not generated by the pipeline, modifying it this way could affect other pipeline");
        }
			};

      /**
       \brief Add a texel buffer to the pipeline and scpecify it's binding and shader stage
       \param texel a pointer to the texel buffer
       \param stage the shader stage where the texel buffer is going to be used
       \param binding the binding point of the texel buffer, 0 by default
       */
      [[deprecated("Deprecated: Create your own descriptor set and bind it to the pipeline instead with setDescirptorSet")]]
			virtual void addTexelBuffer(const Buffer& texel, VkShaderStageFlags stage, int binding = 0) {
        if(!m_descriptorSet){
          m_descriptorSet = std::make_shared< DescriptorSet >();
          m_isDescriptorPipelineGenerated = true;
        }
        if(m_isDescriptorPipelineGenerated){
          m_descriptorSet->addTexelBuffer(texel,stage,binding);
        }else{
          ErrorCheck::setError("Descritpor is not generated by the pipeline, modifying it this way could affect other pipeline");
        }
			};
      
      /**
       \brief Add a buffer to the pipeline and scpecify it's binding and shader stage
       \param buffer a pointer to the texel buffer
       \param stage the shader stage where the texel buffer is going to be used
       \param binding the binding point of the texel buffer, 0 by default
       */
      [[deprecated("Deprecated: Create your own descriptor set and bind it to the pipeline instead with setDescirptorSet")]]
			virtual void addBuffer(const Buffer& buffer, VkShaderStageFlags stage, int binding = 0) {
        if(!m_descriptorSet){
          m_descriptorSet = std::make_shared< DescriptorSet >();
          m_isDescriptorPipelineGenerated = true;
        }
        if(m_isDescriptorPipelineGenerated){
          m_descriptorSet->addBuffer(buffer,stage,binding);
        }else{
          ErrorCheck::setError("Descritpor is not generated by the pipeline, modifying it this way could affect other pipeline");
        }
			};

      
      virtual void setDescriptorSet(std::shared_ptr < DescriptorSet > set) {
        m_descriptorSet = set;
      }

			std::vector<attachment>& getAttachments() {
        if(!m_descriptorSet){
          m_descriptorSet = std::make_shared< DescriptorSet >();
          ErrorCheck::setError("No Descripor was provided for this pipeline, a default one will be used instead", 1);
        }
          
        return  m_descriptorSet->getAttachments();
			};

      virtual ~Pipeline() {
				Device* d = Device::getDevice();
				VkDevice logical = d->getLogicalDevice();

				if (VK_NULL_HANDLE != m_pipeline) {
					vkDestroyPipeline(logical, m_pipeline, nullptr);
					m_pipeline = VK_NULL_HANDLE;
				}

				if (VK_NULL_HANDLE != m_pipelineLayout) {
					vkDestroyPipelineLayout(logical, m_pipelineLayout, nullptr);
					m_pipelineLayout = VK_NULL_HANDLE;
				}

			};

		protected :
			virtual void generateDescriptorLayout();

			void SpecifyPipelineShaderStages(std::vector<Framework::ShaderStageParameters> const& shader_stage_params,
				std::vector<VkPipelineShaderStageCreateInfo>& shader_stage_create_infos);


			bool CreatePipelineLayout(VkDevice                                   logical_device,
				std::vector<VkDescriptorSetLayout> const& descriptor_set_layouts,
				std::vector<VkPushConstantRange> const& push_constant_ranges,
				VkPipelineLayout& pipeline_layout);

			bool CreateGraphicsPipelines(VkDevice                                             logical_device,
				std::vector<VkGraphicsPipelineCreateInfo> const& graphics_pipeline_create_infos,
				VkPipelineCache                                      pipeline_cache,
				std::vector<VkPipeline>& graphics_pipelines);


			VkPipeline																					            m_pipeline = VK_NULL_HANDLE;
			VkPipelineLayout																		            m_pipelineLayout = VK_NULL_HANDLE;

      std::shared_ptr < DescriptorSet >                               m_descriptorSet;
      bool                                                            m_isDescriptorPipelineGenerated =false;
		};
	}
}
