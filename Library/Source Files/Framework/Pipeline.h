#pragma once

#include "ShaderModule.h"
#include "VertexBuffer.h"
#include "DescriptorSet.h"

namespace LavaCake {
	namespace Framework {

    struct constant {
      PushConstant*           constant;
      VkShaderStageFlags      stage;
    };

    /**
     Class Pipeline :
     \brief A generic class to help manage VkPipelines, inherited by the classes ComputePipeline and GraphicPipeline
     */
		class Pipeline {
		public :
			/**
       \brief Add a uniform Buffer to the pipeline and scpecify it's binding and shader stage
       \param uniform a pointer to the uniform buffer
       \param stage the shader stage where the uniform buffer is going to be used
       \param binding the binding point of the uniform shader, 0 by default
      */
			virtual void addUniformBuffer(UniformBuffer* uniform, VkShaderStageFlags stage, int binding = 0) {
        if(m_descriptorSet ==nullptr){
          m_descriptorSet = new DescriptorSet();
          m_isDescriptorPipelineGenerated = true;
        }
        if(m_isDescriptorPipelineGenerated){
          m_descriptorSet->addUniformBuffer(uniform,stage,binding);
        }else{
          ErrorCheck::setError("Descritpor is not generated by the pipeline, modifying it this way could affect other pipeline");
        }
			};

			/**
			 \brief Add a texture Buffer to the pipeline and scpecify it's binding and shader stage
       \param texture a pointer to the texture buffer
       \param stage the shader stage where the texture buffer is going to be used
       \param binding the binding point of the texture buffer, 0 by default
			*/
			virtual void addTextureBuffer(Image* texture, VkShaderStageFlags stage, int binding = 0) {
        if(m_descriptorSet ==nullptr){
          m_descriptorSet = new DescriptorSet();
          m_isDescriptorPipelineGenerated = true;
        }
        if(m_isDescriptorPipelineGenerated){
          m_descriptorSet->addTextureBuffer(texture,stage,binding);
        }else{
          ErrorCheck::setError("Descritpor is not generated by the pipeline, modifying it this way could affect other pipeline");
        }
      };

			/**
			 \brief Add a frame Buffer to the pipeline and scpecify it's binding and shader stage
       \param frame a pointer to the frame buffer
       \param stage the shader stage where the frame buffer is going to be used
       \param binding the binding point of the frame buffer, 0 by default
			*/
			virtual void addFrameBuffer(FrameBuffer* frame, VkShaderStageFlags stage, int binding = 0, uint32_t view = 0) {
        if(m_descriptorSet ==nullptr){
          m_descriptorSet = new DescriptorSet();
          m_isDescriptorPipelineGenerated = true;
        }
        if(m_isDescriptorPipelineGenerated){
          m_descriptorSet->addFrameBuffer(frame,stage,binding,view);
        }else{
          ErrorCheck::setError("Descritpor is not generated by the pipeline, modifying it this way could affect other pipeline");
        }
			}; 

			/**
			 \brief Add a storage Image to the pipeline and scpecify it's binding and shader stage
       \param storage a pointer to the frame buffer
       \param stage the shader stage where the storage image is going to be used
       \param binding the binding point of the storage image, 0 by default
			*/
			virtual void addStorageImage(Image* storage, VkShaderStageFlags stage, int binding = 0) {
        if(m_descriptorSet ==nullptr){
          m_descriptorSet = new DescriptorSet();
          m_isDescriptorPipelineGenerated = true;
        }
        if(m_isDescriptorPipelineGenerated){
          m_descriptorSet->addStorageImage(storage,stage,binding);
        }else{
          ErrorCheck::setError("Descritpor is not generated by the pipeline, modifying it this way could affect other pipeline");
        }
			}; 


			/**
			 \brief Add an attachment to the pipeline and scpecify it's binding and shader stage
       \param attachement a pointer to the attachement
       \param stage the shader stage where the storage image is going to be used
       \param binding the binding point of the storage image, 0 by default
			*/
			virtual void addAttachment(Image* attachement, VkShaderStageFlags stage, int binding = 0) {
        if(m_descriptorSet ==nullptr){
          m_descriptorSet = new DescriptorSet();
          m_isDescriptorPipelineGenerated = true;
        }
        if(m_isDescriptorPipelineGenerated){
          m_descriptorSet->addAttachment(attachement,stage,binding);
        }else{
          ErrorCheck::setError("Descritpor is not generated by the pipeline, modifying it this way could affect other pipeline");
        }
			};

      /**
       \brief Add a texel buffer to the pipeline and scpecify it's binding and shader stage
       \param texel a pointer to the texel buffer
       \param stage the shader stage where the texel buffer is going to be used
       \param binding the binding point of the texel buffer, 0 by default
       */
			virtual void addTexelBuffer(Buffer* texel, VkShaderStageFlags stage, int binding = 0) {
        if(m_descriptorSet ==nullptr){
          m_descriptorSet = new DescriptorSet();
          m_isDescriptorPipelineGenerated = true;
        }
        if(m_isDescriptorPipelineGenerated){
          m_descriptorSet->addTexelBuffer(texel,stage,binding);
        }else{
          ErrorCheck::setError("Descritpor is not generated by the pipeline, modifying it this way could affect other pipeline");
        }
			};
      
      /**
       \brief Add a buffer to the pipeline and scpecify it's binding and shader stage
       \param buffer a pointer to the texel buffer
       \param stage the shader stage where the texel buffer is going to be used
       \param binding the binding point of the texel buffer, 0 by default
       */
			virtual void addBuffer(Buffer* buffer, VkShaderStageFlags stage, int binding = 0) {
        if(m_descriptorSet ==nullptr){
          m_descriptorSet = new DescriptorSet();
          m_isDescriptorPipelineGenerated = true;
        }
        if(m_isDescriptorPipelineGenerated){
          m_descriptorSet->addBuffer(buffer,stage,binding);
        }else{
          ErrorCheck::setError("Descritpor is not generated by the pipeline, modifying it this way could affect other pipeline");
        }
			};

      
			std::vector<attachment>& getAttachments() {
        if(m_descriptorSet==nullptr){
          m_descriptorSet = new DescriptorSet();
          ErrorCheck::setError("No Descripor was provided for this pipeline, a default one will be used instead", 1);
        }
          
        return  m_descriptorSet->getAttachments();
			};

      virtual ~Pipeline() {
				Device* d = Device::getDevice();
				VkDevice logical = d->getLogicalDevice();

				if (VK_NULL_HANDLE != m_pipeline) {
					vkDestroyPipeline(logical, m_pipeline, nullptr);
					m_pipeline = VK_NULL_HANDLE;
				}

				if (VK_NULL_HANDLE != m_pipelineLayout) {
					vkDestroyPipelineLayout(logical, m_pipelineLayout, nullptr);
					m_pipelineLayout = VK_NULL_HANDLE;
				}

				
        if (m_descriptorSet != nullptr) {
          delete m_descriptorSet;
        }

			};

		protected :
			virtual void generateDescriptorLayout();

			void SpecifyPipelineShaderStages(std::vector<Framework::ShaderStageParameters> const& shader_stage_params,
				std::vector<VkPipelineShaderStageCreateInfo>& shader_stage_create_infos);


			bool CreatePipelineLayout(VkDevice                                   logical_device,
				std::vector<VkDescriptorSetLayout> const& descriptor_set_layouts,
				std::vector<VkPushConstantRange> const& push_constant_ranges,
				VkPipelineLayout& pipeline_layout);

			bool CreateGraphicsPipelines(VkDevice                                             logical_device,
				std::vector<VkGraphicsPipelineCreateInfo> const& graphics_pipeline_create_infos,
				VkPipelineCache                                      pipeline_cache,
				std::vector<VkPipeline>& graphics_pipelines);




			VkPipeline																					            m_pipeline = VK_NULL_HANDLE;
			VkPipelineLayout																		            m_pipelineLayout = VK_NULL_HANDLE;

			/*
      VkDescriptorSetLayout															              m_descriptorSetLayout = VK_NULL_HANDLE;
			VkDescriptorPool																		            m_descriptorPool = VK_NULL_HANDLE;
			std::vector<VkDescriptorSet>																		m_descriptorSets;
			std::vector<VkDescriptorPoolSize>																m_descriptorPoolSize;
			std::vector<VkDescriptorSetLayoutBinding>												m_descriptorSetLayoutBinding;
			uint32_t																												m_descriptorCount = 0;

			std::vector<Core::BufferDescriptorInfo>													m_bufferDescriptorUpdate;
			std::vector<Core::ImageDescriptorInfo>													m_imageDescriptorUpdate;
			std::vector<Core::TexelBufferDescriptorInfo>										m_texelBufferDescriptorUpdate;

			std::vector<uniform>																						m_uniforms;
			std::vector<texture>																						m_textures;
			std::vector<frameBuffer>																				m_frameBuffers;
			std::vector<attachment>																					m_attachments;
			std::vector<storageImage>																				m_storageImages;
			std::vector<texelBuffer>																				m_texelBuffers;
			std::vector<buffer>																							m_buffers;
			std::vector<constant>																						m_constants;*/
      
      DescriptorSet*                                                  m_descriptorSet = nullptr;
      bool                                                            m_isDescriptorPipelineGenerated =false;
		};
	}
}
